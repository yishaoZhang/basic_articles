## 单例模式 ##
+ 定义保证一个类只有一个实例
+ 提供一个全局的入口访问实例
```
var Singleton(name) {
    this.name = name;
    this.instance = null;
}
Single.prototype.getName() {
    console.log(this.name);
} 
Singleton.getIntance = function(name) {
    // 注意此处的this 指向 Singleton
    // Singleton 中 this 指向实例
    if (!this.instance) {
        this.intance = new Singleton(name);
    }
    return this.intance;
}

// 消除 Singleton.getIntance 中的 this, 采用闭包标识
Singleton.getInstance = (
    var isInstance = null;
    return function(name) {
        if (!isInstance) {
            isInstance = new Singleton(name);
        }
        return isInstance;
    }
)()

// 上述最大问题是实例通过 Singleton.getInstance() 创建
// 仍可以使用 new Singleton() 创建 且无法保证其单一性。
// 接上解决方案：将构造函数加一层闭包

```

```
// 构造函数加一层闭包（做指针）
var Singleton = (
    var instance = null;
    var constructorExpress = function(name) {
        if (instance) { // 利用闭包将指示变量封在 构造函数体内
            return instance;
        }
        this.name = name
        return instance = this; // 此处稍加注意
    }
    return constructorExpress
)();
```

## 策略模式 ##
+ 需求背景，公司不同职级的计算年终奖
+ 注意对象与策略是一对一的关系，相对而言，命令模式中命令与对象或特定对象中方法是 一 对 多的关系
+ 上述策略与命令模式，消除差异，可替代性较强
```
var strategies = {
    'S': function(salary) {
        return salary * 4;
    },
    'A': function(salary) {
        return salary * 3;
    }, 
    'B': function(salary) {
        return salary * 2;
    }
}
var caculateBonus = function(level, salary) {
    return strategies[leval](salary);
}
// 可以做一总结性理解，将函数表达式与参数分离的传参方式，可以都归为策略模式
```

## 代理模式 ##
+ 任何形式的callback都可以理解为代理，尤其涉及异步
    + callback是独立的函数，但其执行条件受主体（代理）控制
        + 如：页面动态插入<img>
            + let myImage = document.createElement('image');
            + myImage.src = 'url';
            + document.body.appendChild(myImage)
+ js 存在Image对象，给该对象实例 src 属性赋值后，浏览器自动启动下载
+ \<script> 其下载过程为先创建 dom 给其赋 src html动态渲染该元素时将启动下载
```
// 初始化用图片B 代替 图片A的加载，待A下载完成后，用A再代替B展示
var myImage = (function() {
    var imageNode = document.createElement('img');
    document.body.appendChild(imageNode);
    var image = new Image();
    image.onload = function(
        imageNode.src = image.src; // 这里要注意肯定不能直接取src, image是闭包，内外操作的是同一个对象
    )
    return {
        setSrc: function(src) {
            imageNode.src = "B.pic.url";
            image.src = src
        }
    }
})();
myImage.setSrc('A.pic.url');
// 上述代码用的代理的理念，但在程序设计上违反函数的单一性
```
```
// 将上述代码改造
var myImage = (function() {
    var imageNode = document.createElement('img');
    document.body.appendChild(imageNode);
    return function(src) {
                imageNode.src = src;
            }
})();
var imageProxy = (function() {
    var image = new Image();
    image.onload = function() {
        myImage(image.src);
        // 可以考虑将image null掉
    }
    return function(src) {
                myImage('B.pic.url');
                image.src = src;
            }
})();
imageProxy('A.pic.url');
// 上述函数myImage的独立性特别好， 其可以单独使用，亦可以被代理使用
// 注意：上述修正后的代码在生产环境中，myImage应在imageProxy中传参使用，注意其它参数
```

## 迭代器模式 ##
+ 如Array有forEach遍历方法
    + 在实现方式上为在Array对象（或原型链）添加方法
    + 自理解：全局对象添加与全局对象有关的遍历方法即为 迭代模式
    + 举例如：Array.forEach()...
+ es5
```
// es5实现Array.forEach()
Array.prototype.forEach1 = function(callback, _this) {
    var self = this;
    for (let i = 0, lenI = self.length; i < lenI; i++) {
        callback.apply(_this, [self[i], i, self]);
    }
}
// 上述为隐式迭代器
// 上述使用的对象只能通过 new Array(1,2,3) 的形式，隐式的创建数组[1,2,3]不可用，具体原因待查？？
```
```
// es5 显式实现forEach迭代器, 限array
var forEach1 = function(arr,callback, _this) {
        var current = 0;
        return {
            next: function() {
                var isDone = function() {
                    return current > arr.length;
                }
                if (!isDone()) {
                    callback.apply(_this, [arr[current], current, arr]);
                    current++;
                }
            }
        }
    }
    var arrIterator = forEach1([1,2,3], function(element, index){
        console.log(element, index, '123')
    });
    arrIterator.next()
    arrIterator.next()
    arrIterator.next()
// 注意 先通过构造器拿到迭代函数，然后多次执行迭代
// 初次编写代码时将构造器与迭代器放在一起，有何不好?
// 混写意味着所有对象与对象实例共有一个全局函数。加之闭包影响，要消除其内部需添加 对象类型与对象值判断，进而若不等则初始化闭包值。
```